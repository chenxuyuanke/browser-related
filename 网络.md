

# 互联网协议
> 层与协议:每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。

> 大家都遵守的规则，就叫做"协议"（protocol）。

> 互联网的每一层，都定义了很多协议。这些协议的总称，就叫做"互联网协议"（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。

## 五层模型 
- 应⽤层
"应用层"的作用，就是规定应用程序的数据格式。
> HTTP协议，就是浏览器规定的数据格式。
HTTP/1.0 任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。而且HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据（如请求方式，字符的编码，缓存机制，状态码）。1.0的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。

HTTP/1.1版 增加了更多请求方式，1.1版最大有点就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive，还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为"队头堵塞"（Head-of-line blocking）。
为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。

HTTP/2  
二进制协议：HTTP/1.1 版的头信息肯定是文本（ASCII编码),HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。
HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。
多工：HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。这样双向的、实时的通信。

数据流：因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。
HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。
数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。
客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。

头信息压缩：HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。
服务器推送：HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。

### 状态码分类：
1XX- 信息型，服务器收到请求，需要请求者继续操作。
2XX- 成功型，请求成功收到，理解并处理。
3XX - 重定向，需要进一步的操作以完成请求。
4XX - 客户端错误，请求包含语法错误或无法完成请求。
5XX - 服务器错误，服务器在处理请求的过程中发生了错误。
### 常见状态码：

200 OK - 客户端请求成功
301 - 资源（网页等）被永久转移到其它URL
302 - 临时跳转
400 Bad Request - 客户端请求有语法错误，不能被服务器所理解
401 Unauthorized - 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
404 - 请求资源不存在，可能是输入了错误的URL
500 - 服务器内部发生了不可预期的错误
503 Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。

### http和https的区别
http缺点：
请求信息明文传输，容易被窃听截取。
数据的完整性未校验，容易被篡改
没有验证对方身份，存在冒充危险

https：HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。
1. 首先客户端通过URL访问服务器建立SSL连接。
2. 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。
3. 客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级。
4. 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
5. 服务器利用自己的私钥解密出会话密钥。
6. 服务器利用会话密钥加密与客户端之间的通信。

https缺点：
HTTPS协议多次握手，导致页面的加载时间延长近50%；
HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗；
申请SSL证书需要钱，功能越强大的证书费用越高。
SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。

总结：
HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理。
http和https使用连接方式不同，默认端口也不一样，http是80，https是443

- DNS解析 把域名解析成IP地址，IP和域名形成对应关系。
看浏览器的缓存。
本机host。域名映射
127.0.0.1 localhost 
0.0.0.0 不知道ip地址，默认打到本机上。
家⾥路由器
上级路由、城市的LDNS服务器
继续向上级的DNS服务器找。
gDNS服务器。
- 传输层
- "传输层"的功能，就是建立"端口到端口"的通信。相比之下，"网络层"的功能是建立"主机到主机"的通信。只要确定主机和端口，我们就能实现程序之间的交流。
> TCP协议、UDP协议 
> 我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。TCP协议能够确保数据不会遗失，长度不受限制，它的缺点是过程复杂、实现困难、消耗较多的资源。
- 网络层
> 以太网采用广播方式发送数据包，所有成员人手一"包"，不仅效率低，而且局限在发送者所在的子网络。互联网是无数子网络共同组成的一个巨型网络,必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用"路由"方式发送。这就导致了"网络层"的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做"网络地址"，简称"网址"。
"网络层"出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。
网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。
规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。
目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。
通过"子网掩码"，我们就能判断，任意两个IP地址是否处在同一个子网络
ARP协议可以从IP地址得到MAC地址。
- 数据链路层
> 单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？这就是"数据链路层"的功能，它在"实体层"的上方，确定了0和1的分组方式。
> 以太网协议：一组电信号构成一个数据包，叫做"帧"（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。
> "标头"包含数据包的一些说明项，比如发送者、接受者、数据类型等等；"数据"则是数据包的具体内容。
"标头"的长度，固定为18字节。"数据"的长度，最短为46字节，最长为1500字节。因此，整个"帧"最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。

> mac地址：以太网规定，连入网络的所有设备，都必须具有"网卡"接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。以太网数据包必须知道接收方的MAC地址，然后才能发送。以太网采用了一种很"原始"的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方，这种方式叫广播。有了数据包的定义、网卡的MAC地址、广播的发送方式，"链接层"就可以在多台计算机之间传送数据了。但是这里只能在同一子网络下传输。

- 物理层
> 电脑要组网，当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。
> 这就叫做"实体层"，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。


# 跨域

B/S结构 C/S结构
Client/Server——Client只负责内容的展示，Server负责提供内容。
Browser/Server——Browser只负责内容的展示，Server负责提供内容。

服务器返回的是⼀个字符串（HTML只是一种字符串的格式），这个字符串的来源可能是⽂件，可能是缓存，可能来⾃于数据库。
服务器：严格的说，服务器是⼀台计算机，这台计算机，只提供服务。
服务容器：是⼀个程序。程序可以监听⼀个端⼝。读取⽂件，并且返回。

协议，域名，端⼝这三个，有任意⼀个不⼀样就算跨域。同源策略是浏览器的限制。
跨域行为发生在浏览器中:
1. 即使跨域了（协议，域名，端⼝号有不⼀样的），请求也可以发出。
2. 服务器端也是可以接收的。
3. 服务器端也是可以正常处理的。
4. 服务器端也是可以正常返回数据。
5. 浏览器也能接收到这些数据。
6. 接收到之后，发现当前⻚⾯的域和请求的域不同，所以判定为跨域。
7. 我们的代码在这等着结果呢，但是因为浏览器判定跨域了，不会把结果传递给我们的代码。

解决跨域问题：
1. 后端（别⼈家的）配合我们进⾏跨域。
pan.baidu.com ——> zhidao.baidu.com
（1）JSONP（正常的情况，返回的数据都是JSON格式。JSONP是⼀种特殊的格式。）
（2）后端设置Access-Control-Allow-Origin属性以⽀持跨域。（聊天机器⼈课讲，因为需
要nodejs）
2. 后端不配合我们进⾏跨域。
（3）iframe（只能显示，不能控制）
（4）通过后端代理（⾃⼰的后端）（后⾯聊天机器⼈讲，因为需要nodejs）

jsonp格式哪里特殊？
发送的时候，会带上一个参数callback
返回的结果不是json,通过返回js代码的方式来传递数据。
callback的名 + ( + json + );
```js
$.ajax({
    url: "http://developer.duyiedu.com/edu/testJsonp",
    type: "post",
    dataType: "jsonp",
    success: function (data) {
        console.log(data);
    }
});
// 请求地址 https://developer.duyiedu.com/edu/testJsonp?callback=jQuery34107589361415487432_1648743470110

// 返回结果
// jQuery34107589361415487432_1648743470110({status: "ok", msg: "Hello! There is DuYi education!"})

// 调用callback处理数据

jQuery34107589361415487432_1648743470110(data){
    console.log(data)
    // {status: "ok", msg: "Hello! There is DuYi education!"}
}
```

jsonp跨域，只能使用get方法，如果我们设置的是post方法，jquery会自动转为get方法。

script标签，有src属性，所以可以发出网络请求
script标签，虽然可以引用其他域的资源，浏览器不限制。
但是，浏览器会将返回的内容，作为js代码执行。

asd({"status":"ok","msg":"Hello! There is DuYi education!"})
相当于调用了asd方法，传入了一个json对象作为参数。


JSONP原理：
1. 判断请求与当前页面的域，是否同源，如果同源则发送正常的ajax，就没有跨域的事情了。
2. 如果不同源，生成一个script标签
3. 生成一个随机的callback名字，还得创建一个名为这个的方法。
4. 设置script标签的src，设置为要请求的接口。
5. 将callback作为参数拼接在后面。
============以上是前端部分================
1. 后端接收到请求后，开始准备要返回的数据
2. 后端拼接数据，将要返回的数据用callback的值和括号包裹起来
    例如：callback=asd123456，要返回的数据为{"a":1, "b":2},
    就要拼接为：asd123456({"a":1, "b":2});
3. 将内容返回。
============以上是后端部分================
1. 浏览器接收到内容，会当做js代码来执行。
2.  从而执行名为asd123456的方法。这样我们就接收到了后端返回给我们的对象。

